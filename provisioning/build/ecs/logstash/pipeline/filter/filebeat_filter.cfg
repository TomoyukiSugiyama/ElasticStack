filter {
  grok {
    patterns_dir => ["/opt/logstash/extra_patterns"]
    match => { "message" => "%{TIMESTAMP_JP:read_timestamp}" }
  }

  grok {
    match => { "message" => "\nMode,%{WORD:Mode}"}
  }

  grok {
    match => { "message" => "\nTesterName,%{WORD:TesterName}"}
  }

  grok {
    match => { "message" => "\nResult,%{WORD:Result}"}
  }

  date {
    match => ["read_timestamp", "yyyy/MM/dd,HH:mm:ss"]
    timezone => "Asia/Tokyo"
    target => "@timestamp"
  }

  mutate {
      add_field => { "lc_custom_id" => "%{TesterName}-%{Mode}" }
  }

  split{}

  csv {
    columns => ["Step","TstName","Critical","LoLimit","Data","UpLimit","Unit","Judge"]
    separator => ","
  }

  if [Step] !~ /\d+/ {
    drop{}
  }

  mutate {
    convert => {
      "Step" => "integer"
      "LoLimit" => "float"
      "Data" => "float"
      "UpLimit" => "float"
    }
  }

  fingerprint {
    source => "message"
    target => "[@metadata][fingerprint]"
    method => "MD5"
    key => "test"
  }

  ruby { code => 'event.set("[@metadata][prefix]", event.get("@timestamp").to_i.to_s(16))' }

}